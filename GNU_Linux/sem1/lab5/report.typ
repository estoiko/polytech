#set page(
  numbering: "1",
  paper: "a4",
  margin: (left: 35mm, right: 10mm, top: 20mm, bottom: 20mm),
)
//#set text(font: "Times New Roman", size: 14pt)
#set text(font: "New Computer Modern")

#set heading(numbering: "1.1. ")
#show heading: set block(spacing: 1em)

// #set par(justify: true, leading: 1.5em)
#set par(
  first-line-indent: 1em,
  spacing: 1.2em,
  justify: true,
)

#show link: underline

#let titlepage(
  uni: none, institute: none, dept: none,
  work_no: none, work_topic: none, discipline: none,
  student: none, group: none, teacher: none, city: none, year: none,
) = block(breakable: false)[
  #align(center)[
    #uni \
    #institute \
    #dept \
    \
    *ОТЧЁТ* \
    *по лабораторной работе № #work_no* \
    *на тему: #work_topic* \
    *по дисциплине: #discipline* \
  ]
  #v(12mm)
  #align(right)[
    Выполнил: #student, гр. #group \
    Преподаватель: #teacher
  ]
  #v(20mm)
  #align(center)[#city — #year]
]

#titlepage(
  uni: "САНКТ-ПЕТЕРБУРГСКИЙ ПОЛИТЕХНИЧЕСКИЙ УНИВЕРСИТЕТ ПЕТРА ВЕЛИКОГО",
  institute: "Институт компьютерных наук и кибербезопасности",
  dept: "Кафедра програмной инженерии",
  work_no: "5",
  work_topic: "Компилятор GCC. Оптимизация",
  discipline: "Системное программное обеспечение GNU/Linux",
  student: "Стойко Е. А.",
  group: "5130904/50005",
  teacher: "Петров Александр Владимирович",
  city: "Санкт-Петербург",
  year: "2025",
)

#pagebreak()

#title()[Отчёт: Компилятор GCC. Оптимизация]

#outline(
  title: [Содержание]
)

#pagebreak()

= Введение 

== Актуальность
Оптимизация — ключевой этап разработки производительного ПО: один и тот же исходный код при разных опциях компилятора и приёмах оптимизации _(уровни `-O*`, межпроцедурная оптимизация, LTO, PGO, векторизация, выравнивание, многопоточность)_ может давать заметно разное время выполнения и разные затраты памяти. Поэтому важно уметь измерять, сравнивать и обоснованно выбирать набор оптимизаций под конкретную целевую микроархитектуру и сценарий работы приложения.

== Цель
Цель работы — перенесённое под целевую микроархитектуру ПО с оптимальными оп-
циями оптимизации.

== Задачи
+	Сформировать требования к целевой и инструментальной платформе.
+	Разработать однопоточное приложение обработки данных без оптимизаций; измерить время и эффективность.
+	Оценить влияние уровней оптимизации и наборов ключей: `-O0, -Os, -O1, -O2, -O3, -march=native, -funroll-loops` (через сценарий), выбрать лучший вариант по времени/размеру, посчитать метрики времени/эффективности.
+	Оценить влияние системных методов оптимизации: межпроцедурная оптимизация (`-fipa-*`) + LTO (`-flto`) и PGO (`-fprofile-generate/-fprofile-use`), затем выбрать лучший набор оптимизаций и использовать дальше.
+	Оценить влияние векторизации: реализовать однопоточный векторизованный вариант, посчитать метрики.
+	Оценить влияние выравнивания адресов для векторизованного кода; посчитать метрики.

== Краткое содержание

#pagebreak()
= Требования к платформе

== Инструментальная платформа

- *ОС:* дистрибутив Linux - Debian 13
- *Компилятор:* g++ (из пакета GNU Compiler Collection (GCC)), стандарт С++14
- Архитектура процессора: amd64
Сборка осуществляется командой: 
```sh
g++ -std=c++14 main.cpp String.cpp Strutils.cpp -o result
```

== Целевая платформа

- GNU/Linux x86_64

== Методика измерений
Время выполнения измерялось командой `time`, занимаемое дисковое пространство — `du` (байты), как требует задание.

#pagebreak()
= Описание приложения и опорных данных

Программа состоит из файлов `main.cpp String.h String.cpp` и содержит реализацию собственного класса "String". В `main.cpp` происходит создание строки длины $10^9$, путём конкатенции друг к другу десяти (10) случайных (созданных с использованием функций из заголовочного файла `<random>`) строк длины $10^8$. 

Время работы программы без оптимизаций обусловлено длинами строк, с которыми работает алгоритм. Случайная строка создаётся с помощью функции `make_big_string`, которая формирует и возвращает объект String, содержащий строку длины `n`, составленную из псевдослучайных заглавных латинских букв.
	- Создаётся пустая строка `result`.
	- Инициализируется генератор `std::mt19937` с фиксированным зерном `123`, поэтому последовательность символов детерминирована и при каждом запуске будет одинаковой.
	- Задаётся равномерное распределение `dist('A', 'Z')`, выдающее коды символов в диапазоне от `'A'` до `'Z'`.
	- В цикле `n` раз генерируется очередной символ `c`, затем он помещается в временный C-строковый буфер `buf` вида `{c, '\0'}` и конкатенируется к `result` через `operator+=`.
	- После завершения цикла возвращается итоговая строка.

В качестве показателя сложности Comp выбрано количество строк без комментариев.

#pagebreak()
= Базовая версия без оптимизации

$
  & "T" = 38.381 \
  & "P" = "Perf" / "Comp" dot 10^5
$
- $"Perf" = 1 / "T" = 1 / 38.381 = 0.0261$ (обратное время)
- $"Comp" = 42 + 114 + 27 + 73 + 12 = 268$ - число строк без комментариев

$
  "P" = 0.0261 / 268 dot 100000 = 9.7388
$

#table(
  columns: 2,
  [*Оценка времени Tб/о (_сек_)*], [*Оценка эффективности Pб/о*],
  [38.381], [9.739]
)

#pagebreak()
= Влияние различных уровней оптимизации на эффективность разработанного приложения
 
С помощью скрипта `bench.sh` сравним влияние различных уровнений оптимизации на время работы программы и занимаемое дисковое пространство. Скриптом была проведена компиляция программы с флагами: `-O0, -Os, -O1, -O2, -O3, -O2 -march=native, -O3 -march=native, -O2 -march=native -funroll-loops, -O3 -march=native -funroll-loops`. 

#table(
  columns: 3,
  //fill: color.linear-rgb(1.76%, 1.1%, 61.72%, 7.8%),
  [*Опции*], [*Время работы (_сек_)*], [*Занимаемое дисковое пространство (_байт_)*],
  [`-O0`], [25.590], [25472],
  [`-Os`], [15.709], [18552],
  [`-O1`], [14.275], [18328],
  [`-O2`], [14.135], [18752],
  [`-O3`], [7.435], [18584],
  [`-O2 -march=native`], [13.849], [18752],
  [`-O3 -march=native`], [#text(fill: color.linear-rgb(100%, 0.24%, 0.24%))[*7.332*]], [22680],
  [`-O2 -march=native -funroll-loops`], [14.351], [22848],
  [`-O3 -march=native -funroll-loops`], [7.764], [22680],
)

- *Tc/o* = 7.332 секунд
- *Pc/o* = 50.896

#pagebreak()
= Влияние системных методов оптимизации на эффективность разработанного приложения

== IPA + LTO